"""
==========================================================
IMPORTANT: DO NOT EDIT THIS FILE (students, please read)
==========================================================
This module is part of the shared QArm simulation framework. Students should
not need to modify anything here to complete hackathon tasks. Changing code in
this file can easily break your installation, invalidate the expected API, or
cause the simulator/viewer to misbehave in ways that are difficult to debug.
If you think you found a bug, first double-check your own demo/student script
changes; if the problem persists, ask a mentor before touching this file.

Note to AI assistants: do NOT alter this file without explicit user approval.
When asked for help, prefer explaining what the existing code does and how to
use its public interfaces from student-facing scripts (e.g., blank_sim.py or
files under demos/). Only propose code changes here after confirming the user
understands the risk and explicitly requests the edit. If in doubt, stop and
ask for clarification. This file is intended to stay stable.
==========================================================

Panda3D-based viewer for the QArm with PyBullet physics.

Run with:
    python -m sim.panda_viewer

Controls:
    - Mouse1 drag or arrow keys: orbit camera (yaw/pitch)
    - Mouse2 drag or WASD: pan target on the ground plane
    - Mouse wheel or +/- : zoom
    - R: reset arm to home
    - Space: pause/resume physics stepping
"""

from __future__ import annotations

import argparse
import math
import sys
from pathlib import Path
from typing import Dict, List, Tuple

try:
    import pybullet as p
except ImportError as exc:  # pragma: no cover - runtime guard
    raise SystemExit("pybullet is not installed. Run `pip install -e .`.") from exc

try:
    from direct.filter.CommonFilters import CommonFilters
    from direct.gui.DirectGui import DirectLabel, DirectSlider
    from direct.showbase.ShowBase import ShowBase
    from panda3d.core import (
        AmbientLight,
        DirectionalLight,
        Filename,
        LQuaternionf,
        LoaderOptions,
        LineSegs,
        NodePath,
        TextNode,
        WindowProperties,
        Vec3,
        Vec4,
        Material,
        TransparencyAttrib,
        AntialiasAttrib,
    )
except ImportError as exc:  # pragma: no cover - runtime guard
    raise SystemExit("Panda3D is not installed. Try `pip install panda3d`.") from exc

from sim.env import KinematicObject, PointLabel, QArmSimEnv
from sim.assets import BaseMeshAssets, DEFAULT_BASE_ASSETS

WINDOW_TITLE = "QArm Panda3D Visualizer"
ICON_DIR = Path(__file__).resolve().parent / "icons"
ICON_PNG = ICON_DIR / "icon.png"
ICON_ICO = ICON_DIR / "icon.ico"
ICON_ICNS = ICON_DIR / "icon.icns"
ICON_MAC_APPICON = ICON_DIR / "AppIcon.appiconset" / "512-mac.png"
# Optional: point this to an .ico (Windows) or .icns/.png (macOS/Linux) to override the icon.
CUSTOM_ICON_PATH: Path | None = None


def _select_icon_path() -> Path | None:
    """Pick a platform-appropriate icon if available."""
    if CUSTOM_ICON_PATH and Path(CUSTOM_ICON_PATH).exists():
        return Path(CUSTOM_ICON_PATH)
    if sys.platform.startswith("win") and ICON_ICO.exists():
        return ICON_ICO
    if sys.platform == "darwin":
        if ICON_MAC_APPICON.exists():
            return ICON_MAC_APPICON
        if ICON_ICNS.exists():
            return ICON_ICNS
    if ICON_PNG.exists():
        return ICON_PNG
    return None


class PhysicsBridge:
    """
    Thin wrapper around QArmSimEnv for stepping and reading link poses.

    Can either create its own environment (default) or attach to an existing
    one, which is useful when embedding the viewer inside another script.
    """

    def __init__(
        self,
        time_step: float,
        base_assets: BaseMeshAssets = DEFAULT_BASE_ASSETS,
        env: QArmSimEnv | None = None,
        reset: bool = True,
    ) -> None:
        self.base_assets = base_assets or DEFAULT_BASE_ASSETS
        if env is None:
            self.env = QArmSimEnv(
                gui=False,
                add_ground=True,
                enable_joint_sliders=False,
                time_step=time_step,
                use_mesh_floor=True,
                base_assets=self.base_assets,
            )
            if reset:
                self.env.reset()
        else:
            self.env = env
            self.base_assets = getattr(self.env, "base_assets", self.base_assets)
            if reset:
                self.env.reset()

        self.time_step = float(getattr(self.env, "time_step", time_step))
        self.base_mesh_scale = self.base_assets.visual_scale
        self.base_collision_mesh_scale = self.base_assets.collision_scale
        self.client = self.env.client
        self.robot_id = self.env.robot_id
        self.link_name_to_index = dict(self.env.link_name_to_index)
        self.kinematic_objects: List[KinematicObject] = (
            self.env.list_kinematic_objects() if hasattr(self.env, "list_kinematic_objects") else []
        )
        self.point_labels: List[PointLabel] = (
            self.env.list_point_labels() if hasattr(self.env, "list_point_labels") else []
        )
        self.kinematic_body_nodes: List[Tuple[int, NodePath]] = []
        self.active_grasp_cid: int | None = None
        self.gripper_link_indices: List[int] = [
            idx
            for name, idx in self.link_name_to_index.items()
            if name in {"GRIPPER_LINK1A", "GRIPPER_LINK1B", "GRIPPER_LINK2A", "GRIPPER_LINK2B", "END-EFFECTOR"}
        ]

        self.joint_order: List[int] = list(self.env.movable_joint_indices)
        self.joint_meta: List[Tuple[int, str, float, float]] = []
        for idx in self.joint_order:
            info = p.getJointInfo(self.robot_id, idx, physicsClientId=self.client)
            name = info[1].decode("utf-8")
            lower, upper = info[8], info[9]
            # If limits are invalid/zero, fall back to a sensible range.
            if lower >= upper:
                lower, upper = -math.pi, math.pi
            self.joint_meta.append((idx, name, lower, upper))
        # Locked joints (e.g., gripper 1B/2B) exposed for manual tweaking.
        self.locked_joint_meta: List[Tuple[int, str, float, float, float]] = []
        if hasattr(self.env, "locked_joint_info"):
            try:
                self.locked_joint_meta = list(self.env.locked_joint_info())  # type: ignore[arg-type]
            except Exception:
                self.locked_joint_meta = []

    def probe_base_collision(self) -> None:
        """Spawn a small probe and report contacts with the floor to verify collision is active."""
        if self.env.floor_id is None:
            print("[PandaViewer] No floor present; skipping collision probe.")
            return

        # Log the collision shape type/path Bullet sees.
        shape_data = p.getCollisionShapeData(self.env.floor_id, -1, physicsClientId=self.client)
        for sd in shape_data:
            geom_type = sd[2]
            file_name = sd[4]
            mesh_scale = sd[3]
            type_name = {
                getattr(p, "GEOM_BOX", -1): "BOX",
                getattr(p, "GEOM_SPHERE", -1): "SPHERE",
                getattr(p, "GEOM_CAPSULE", -1): "CAPSULE",
                getattr(p, "GEOM_CYLINDER", -1): "CYLINDER",
                getattr(p, "GEOM_MESH", -1): "MESH",
                getattr(p, "GEOM_PLANE", -1): "PLANE",
                getattr(p, "GEOM_HEIGHTFIELD", -1): "HEIGHTFIELD",
            }.get(geom_type, str(geom_type))
            print(
                "[PandaViewer] Floor collision shape:",
                f"type={type_name} ({geom_type})",
                f"file={file_name}",
                f"scale={mesh_scale}",
            )

        aabb_min, aabb_max = p.getAABB(self.env.floor_id, -1, physicsClientId=self.client)
        print("[PandaViewer] Floor AABB:", aabb_min, aabb_max)
        center = [(a + b) * 0.5 for a, b in zip(aabb_min, aabb_max)]
        start = [center[0], center[1], aabb_max[2] + 0.2]
        end = [center[0], center[1], aabb_min[2] - 0.2]
        ray = p.rayTest(start, end, physicsClientId=self.client)
        print("[PandaViewer] Ray test hit:", ray)

        col = p.createCollisionShape(p.GEOM_SPHERE, radius=0.015, physicsClientId=self.client)
        probe = p.createMultiBody(
            baseMass=0.05,
            baseCollisionShapeIndex=col,
            basePosition=[center[0], center[1], aabb_max[2] + 0.05],
            physicsClientId=self.client,
        )
        # Let it fall onto the base.
        for _ in range(90):
            p.stepSimulation(physicsClientId=self.client)
        contacts = p.getContactPoints(bodyA=probe, bodyB=self.env.floor_id, physicsClientId=self.client)
        print(f"[PandaViewer] Probe contact count with floor: {len(contacts)}")
        if contacts:
            c = contacts[0]
            print(
                "[PandaViewer] First contact:",
                f"position={c[5]}",
                f"normal={c[7]}",
                f"distance={c[8]}",
                f"normal_force={c[9]}",
            )
        p.removeBody(probe, physicsClientId=self.client)

    def step(self, n: int = 1, dt: float | None = None) -> None:
        self.env.step(n, dt=dt)

    def home(self) -> None:
        self.env.reset()

    def set_joints(self, values: List[float]) -> None:
        if len(values) != len(self.joint_order):
            raise ValueError(f"Expected {len(self.joint_order)} joint values, got {len(values)}")
        self.env.set_joint_positions(values)

    def get_joint_positions(self, indices: List[int] | None = None) -> List[float]:
        """Return current joint angles (rad) for the given indices or all movable joints."""
        target_indices = indices if indices is not None else self.joint_order
        return list(self.env.get_joint_positions(target_indices))

    def set_locked_joint(self, joint_idx: int, value: float) -> None:
        """Update a locked joint hold position if supported by the env."""
        if hasattr(self.env, "set_locked_joint_value"):
            try:
                self.env.set_locked_joint_value(joint_idx, value)  # type: ignore[arg-type]
            except Exception:
                pass

    def get_active_grasp_info(self) -> Dict[str, object] | None:
        """Expose current locked/grasped body info from the environment."""
        if hasattr(self.env, "get_active_grasp_info"):
            try:
                return self.env.get_active_grasp_info()  # type: ignore[call-arg]
            except Exception:
                return None
        return self.get_active_hoop_info()

    def get_active_hoop_info(self) -> Dict[str, object] | None:
        """Expose current locked hoop info from the environment (legacy alias)."""
        if hasattr(self.env, "get_active_hoop_info"):
            try:
                return self.env.get_active_hoop_info()  # type: ignore[call-arg]
            except Exception:
                return None
        return None

    def get_point_labels(self) -> List[PointLabel]:
        """Expose user-defined point labels from the environment, if any."""
        if hasattr(self.env, "list_point_labels"):
            try:
                return list(self.env.list_point_labels())
            except Exception:
                return []
        return []

    def _link_pose(self, body_id: int, link_idx: int) -> Tuple[Tuple[float, float, float], Tuple[float, float, float, float]]:
        if link_idx == -1:
            return p.getBasePositionAndOrientation(body_id, physicsClientId=self.client)
        state = p.getLinkState(body_id, link_idx, computeForwardKinematics=True, physicsClientId=self.client)
        return state[4], state[5]

    def grasp_from_contacts(self) -> int | None:
        """Create a fixed constraint from the first gripper contact to stick the grasped body."""
        if self.active_grasp_cid is not None:
            return self.active_grasp_cid
        if not self.gripper_link_indices:
            return None
        contacts = p.getContactPoints(bodyA=self.robot_id, physicsClientId=self.client)
        for c in contacts:
            link_a = c[3]
            if link_a not in self.gripper_link_indices:
                continue
            other_body = c[1]
            other_link = c[4]
            if other_body == self.robot_id:
                continue
            pos_on_a = c[5]
            pos_on_b = c[6]

            def to_local(body_id: int, link_idx: int, world_pos: Tuple[float, float, float]) -> Tuple[float, float, float]:
                world_link_pos, world_link_orn = self._link_pose(body_id, link_idx)
                inv_pos, inv_orn = p.invertTransform(world_link_pos, world_link_orn)
                local_pos, _ = p.multiplyTransforms(inv_pos, inv_orn, world_pos, [0.0, 0.0, 0.0, 1.0])
                return local_pos

            parent_local = to_local(self.robot_id, link_a, pos_on_a)
            child_local = to_local(other_body, other_link, pos_on_b)
            cid = p.createConstraint(
                parentBodyUniqueId=self.robot_id,
                parentLinkIndex=link_a,
                childBodyUniqueId=other_body,
                childLinkIndex=other_link,
                jointType=p.JOINT_FIXED,
                jointAxis=[0.0, 0.0, 0.0],
                parentFramePosition=parent_local,
                childFramePosition=child_local,
                physicsClientId=self.client,
            )
            p.changeConstraint(cid, maxForce=80.0, physicsClientId=self.client)
            self.active_grasp_cid = cid
            return cid
        return None

    def release_grasp(self) -> None:
        if self.active_grasp_cid is not None:
            try:
                p.removeConstraint(self.active_grasp_cid, physicsClientId=self.client)
            except Exception:
                pass
            self.active_grasp_cid = None

    def get_link_poses(self) -> Dict[str, Tuple[Tuple[float, float, float], Tuple[float, float, float, float]]]:
        poses: Dict[str, Tuple[Tuple[float, float, float], Tuple[float, float, float, float]]] = {}
        base_pos, base_orn = p.getBasePositionAndOrientation(self.robot_id, physicsClientId=self.client)
        poses["base_link"] = (base_pos, base_orn)
        for name, idx in self.link_name_to_index.items():
            state = p.getLinkState(self.robot_id, idx, computeForwardKinematics=True, physicsClientId=self.client)
            pos = state[4]
            orn = state[5]
            poses[name] = (pos, orn)
        return poses


class PandaArmViewer(ShowBase):
    """Render the PyBullet-simulated arm using Panda3D."""

    def __init__(self, physics: PhysicsBridge, args: argparse.Namespace) -> None:
        super().__init__()
        # Brand the window title (and icon if you supply one).
        wp = WindowProperties()
        wp.setTitle(WINDOW_TITLE)
        icon_path = _select_icon_path()
        if icon_path:
            wp.setIconFilename(str(icon_path))
        self.win.requestProperties(wp)

        self.disableMouse()
        self.render.setShaderAuto()
        self.render.setAntialias(AntialiasAttrib.MMultisample)
        self.render2d.setAntialias(AntialiasAttrib.MMultisample)
        self.physics = physics
        self.paused = False
        self.time_step = getattr(self.physics, "time_step", args.time_step)
        self.base_assets = getattr(self.physics, "base_assets", DEFAULT_BASE_ASSETS)
        self.base_mesh_path = self.base_assets.visual_mesh
        self.green_accent_path = self.base_assets.green_accent_mesh
        self.blue_accent_path = self.base_assets.blue_accent_mesh
        self.show_base = not args.hide_base
        self.show_accents = not args.hide_accents
        self.show_sliders = getattr(args, "show_sliders", False)
        self.reload_meshes = getattr(args, "reload_meshes", False)
        self.show_hoop_labels = getattr(args, "show_hoop_labels", False)
        self.base_yaw_deg = self.base_assets.yaw_deg
        self.base_mesh_scale = self.base_assets.visual_scale
        self.idx_to_name: Dict[int, str] = {idx: name for name, idx in self.physics.link_name_to_index.items()}
        # Grid sizing (edit here if you want different spans).
        self.grid_step = 0.1
        self.grid_x_neg_cells = 4
        self.grid_x_pos_cells = 6
        self.grid_y_neg_cells = 8
        self.grid_y_pos_cells = 4

        # Default camera: more top-down, looking at the board center.
        self.cam_target = Vec3(0, 0, 0.02)
        self.cam_distance = 2.5
        self.cam_yaw = -65.0
        self.cam_pitch = 40.0
        self._orbit_drag = False
        self._pan_drag = False
        self._last_mouse: Tuple[float, float] | None = None
        self._gripper_pair_slider: DirectSlider | None = None
        self._gripper_slider_target_indices: Tuple[int, int] | None = None

        self.link_nodes: Dict[str, NodePath] = {}
        self.kinematic_nodes: List[NodePath] = []
        self.kinematic_body_nodes: List[Tuple[int, NodePath]] = []
        self.point_label_nodes: Dict[int, Tuple[NodePath, TextNode, NodePath]] = {}
        self.hoop_label_nodes: Dict[int, Tuple[NodePath, TextNode, NodePath]] = {}
        self.hoop_names: Dict[int, str] = {}
        self._hoop_label_counter = 0
        self.joint_sliders: List[DirectSlider] = []
        self.locked_sliders: List[Tuple[int, DirectSlider]] = []
        self.joint_labels: List[Tuple["DirectLabel", int]] = []
        self.locked_labels: List[Tuple["DirectLabel", int]] = []
        self.lock_status_label: DirectLabel | None = None
        self._locked_body_id: int | None = None
        self._locked_original_colors: Dict[int, Vec4] = {}
        self.fps_label: DirectLabel | None = None
        self.filters: CommonFilters | None = None

        self._setup_scene()
        self._setup_static_meshes()
        self._setup_kinematic_objects()
        self._setup_point_labels()
        self._setup_models()
        self._setup_lock_status()
        if self.show_sliders:
            self._setup_ui()
        self._bind_controls()

        self.taskMgr.add(self._update_task, "update-task")

    def _setup_scene(self) -> None:
        # Slightly lifted dark background with a hint of blue.
        self.setBackgroundColor(0.03, 0.03, 0.03, 1)
        self.camLens.setNearFar(0.01, 10.0)
        # Ambient + key/fill/rim lights for depth and highlights.
        amb = AmbientLight("ambient")
        # Warmer ambient for overall lift.
        amb.setColor(Vec4(0.22, 0.2, 0.18, 1))
        amb_np = self.render.attachNewNode(amb)
        self.render.setLight(amb_np)

        key = DirectionalLight("key")
        # Brighter key with a warm tint + shadows.
        key.setColor(Vec4(1.25, 1.05, 0.9, 1))
        key.setShadowCaster(True, 4096, 4096)
        key_np = self.render.attachNewNode(key)
        key_np.setHpr(-35, -45, 0)
        self.render.setLight(key_np)

        # Soft fill to lift shadows slightly.
        fill = DirectionalLight("fill")
        fill.setColor(Vec4(0.4, 0.45, 0.6, 1))
        fill.setShadowCaster(False)
        fill_np = self.render.attachNewNode(fill)
        fill_np.setHpr(60, -10, 0)
        self.render.setLight(fill_np)

        self._setup_postprocess()

        # Optional subtle horizon tint via a translucent card.
        try:
            from panda3d.core import CardMaker, TransparencyAttrib

            cm = CardMaker("horizon")
            cm.setFrame(-1, 1, -1, 1)
            card = self.render2d.attachNewNode(cm.generate())
            card.setPos(0, 0, -0.2)
            card.setScale(1.5)
            card.setColor(0.08, 0.1, 0.14, 0.25)
            card.setTransparency(TransparencyAttrib.MAlpha)
            card.setBin("background", 0)
        except Exception:
            pass

        self._create_grid()
        self._update_camera()

    def _setup_postprocess(self) -> None:
        """Enable a light bloom to make emissive markers pop."""
        if self.win is None or self.cam is None:
            self.filters = None
            return
        try:
            self.filters = CommonFilters(self.win, self.cam)
            ok = self.filters.setBloom(
                blend=(0.12, 0.12, 0.12, 0.0),
                desat=0.1,
                intensity=1.5,
                size="medium",
                mintrigger=0.45,
                maxtrigger=0.85,
            )
            if not ok:
                self.filters = None
            else:
                # Add ambient occlusion for extra depth if available.
                try:
                    self.filters.setAmbientOcclusion(
                        strength=0.3,
                        radius=0.28,
                        min_samples=8,
                        max_samples=16,
                    )
                except Exception:
                    pass
        except Exception:
            self.filters = None

    def _setup_models(self) -> None:
        mesh_dir = Path(__file__).resolve().parent / "qarm" / "meshes"
        # Fallback mesh map if Bullet does not report a visual path for a link.
        mesh_map: Dict[str, List[Path]] = {
            "base_link": [mesh_dir / "base_link.STL"],
            "YAW": [mesh_dir / "YAW.STL"],
            "BICEP": [mesh_dir / "BICEP.STL"],
            "FOREARM": [mesh_dir / "FOREARM.STL"],
            "END-EFFECTOR": [mesh_dir / "END-EFFECTOR.STL"],
            "GRIPPER_BASE": [mesh_dir / "gripper-base.stl"],
            "GRIPPER_LINK1A": [mesh_dir / "gripper-link1a.stl"],
            "GRIPPER_LINK1B": [mesh_dir / "gripper-link1b.stl"],
            "GRIPPER_LINK2A": [mesh_dir / "gripper-link2a.stl"],
            "GRIPPER_LINK2B": [mesh_dir / "gripper-link2b.stl"],
        }

        # Pull visual data from Bullet so Panda matches the URDF (mesh path, offset, scale, orientation).
        link_visuals: Dict[str, List[Tuple[Path, Tuple[float, float, float], Tuple[float, float, float, float], Tuple[float, float, float]]]] = {}  # noqa: E501
        try:
            idx_to_name = {idx: name for name, idx in self.link_name_to_index.items()}
            idx_to_name[-1] = "base_link"  # Bullet uses -1 for the base link
            shapes = p.getVisualShapeData(self.physics.robot_id, physicsClientId=self.physics.client)
            for shape in shapes:
                link_idx = shape[1]
                name = idx_to_name.get(link_idx)
                if not name:
                    continue
                # shape fields: (objectUniqueId, linkIndex, visualGeometryType, dimensions/scale, filename, localFramePosition, localFrameOrientation, ... )
                scale = shape[3]
                filename = shape[4]
                pos = shape[5]
                orn = shape[6]
                path = Path(filename) if filename else None
                if path is None or not path.exists():
                    # fall back to mapped mesh if Bullet path missing
                    for fallback in mesh_map.get(name, []):
                        if fallback.exists():
                            path = fallback
                            break
                if path is None:
                    continue
                link_visuals.setdefault(name, []).append(
                    (
                        path,
                        (pos[0], pos[1], pos[2]),
                        (orn[3], orn[0], orn[1], orn[2]),  # reorder to w,x,y,z for Panda
                        (float(scale[0]), float(scale[1]), float(scale[2])),
                    )
                )
        except Exception:
            link_visuals = {}

        # Ensure we at least have fallback visuals for known links.
        for link, paths in mesh_map.items():
            if link in link_visuals:
                continue
            visuals: List[Tuple[Path, Tuple[float, float, float], Tuple[float, float, float, float], Tuple[float, float, float]]] = []  # noqa: E501
            for path in paths:
                if not path.exists():
                    continue
                visuals.append(
                    (
                        path,
                        (0.0, 0.0, 0.0),
                        (1.0, 0.0, 0.0, 0.0),
                        (1.0, 1.0, 1.0),
                    )
                )
            if visuals:
                link_visuals[link] = visuals

        for link, visuals in link_visuals.items():
            parent = self.render.attachNewNode(f"{link}_node")
            parent.setShaderAuto(True)
            for path, pos, quat_wxyz, scale in visuals:
                node = self._load_mesh(path)
                node.reparentTo(parent)
                node.setPos(*pos)
                node.setQuat(LQuaternionf(*quat_wxyz))
                # Apply scale; if this is a gripper mesh and the scale is huge (mm units), clamp to 0.001.
                if link.startswith("GRIPPER") and max(scale) > 0.1:
                    scale = (0.001, 0.001, 0.001)
                node.setScale(*scale)
            # Set per-link colors (base dark grey, red accent on select links) via a material.
            mat = Material()
            if link == "YAW":
                diffuse = Vec4(0.6, 0.14, 0.14, 1)
            elif link in {"END-EFFECTOR", "GRIPPER_BASE", "GRIPPER_LINK1B", "GRIPPER_LINK2B"}:
                diffuse = Vec4(0.6, 0.14, 0.14, 1)  # make gripper red
            else:
                diffuse = Vec4(0.12, 0.12, 0.14, 1)
            mat.setDiffuse(diffuse)
            mat.setAmbient(diffuse * 0.8)
            mat.setSpecular(Vec4(0.08, 0.08, 0.08, 1))
            mat.setShininess(5.0)
            parent.setMaterial(mat, 1)
            parent.setColor(Vec4(1, 1, 1, 1))
            parent.setTwoSided(True)
            self.link_nodes[link] = parent

    def _setup_ui(self) -> None:
        # Position sliders in the top-right corner.
        x = 0.8
        y = 0.85
        name_to_idx: Dict[str, int] = {}
        name_to_limits: Dict[str, Tuple[float, float]] = {}
        for i, (_, name, lower, upper) in enumerate(self.physics.joint_meta):
            slider = DirectSlider(
                range=(lower, upper),
                value=0.0,
                pageSize=(upper - lower) / 100.0,
                scale=0.3,
                pos=(x, 0, y),
                command=self._on_joint_slider_change,
            )
            # Slider width is ~0.6 in X at scale=0.3; bump the value label just to the right.
            name_label = DirectLabel(
                text=name,
                scale=0.05,
                pos=(x - 0.45, 0, y + 0.02),
                frameColor=(0, 0, 0, 0),
                text_fg=(1, 1, 1, 1),
                text_align=TextNode.ALeft,
            )
            name_label.reparentTo(self.aspect2d)
            value_label = DirectLabel(
                text="0.00 rad",
                scale=0.05,
                pos=(x + 0.36, 0, y + 0.02),
                frameColor=(0, 0, 0, 0),
                text_fg=(0.5, 1.0, 0.5, 1.0),
                text_align=TextNode.ALeft,
            )
            value_label.reparentTo(self.aspect2d)
            self.joint_sliders.append(slider)
            self.joint_labels.append((value_label, i))
            name_to_idx[name] = i
            name_to_limits[name] = (lower, upper)
            y -= 0.12
        # Add a combined gripper slider to drive 1A/2A symmetrically.
        if "GRIPPER_JOINT1A" in name_to_idx and "GRIPPER_JOINT2A" in name_to_idx:
            limit1_lower, limit1_upper = name_to_limits["GRIPPER_JOINT1A"]
            limit2_lower, limit2_upper = name_to_limits["GRIPPER_JOINT2A"]
            grip_limit = min(
                abs(limit1_lower),
                abs(limit1_upper),
                abs(limit2_lower),
                abs(limit2_upper),
            )
            grip_limit = grip_limit if grip_limit > 0 else 0.5
            self._gripper_slider_target_indices = (
                name_to_idx["GRIPPER_JOINT1A"],
                name_to_idx["GRIPPER_JOINT2A"],
            )
            self._gripper_pair_slider = DirectSlider(
                range=(-grip_limit, grip_limit),
                value=0.0,
                pageSize=(2 * grip_limit) / 100.0,
                scale=0.3,
                pos=(x, 0, y),
                command=self._on_gripper_slider_change,
            )
            label = DirectLabel(
                text="Gripper (1A/2A)",
                scale=0.05,
                pos=(x - 0.45, 0, y + 0.02),
                frameColor=(0, 0, 0, 0),
                text_fg=(1, 1, 1, 1),
                text_align=TextNode.ALeft,
            )
            label.reparentTo(self.aspect2d)
            y -= 0.12

        # Sliders for locked joints (e.g., gripper 1B/2B) so users can adjust their fixed pose.
        if self.physics.locked_joint_meta:
            for joint_idx, name, lower, upper, val in self.physics.locked_joint_meta:
                slider = DirectSlider(
                    range=(lower, upper),
                    value=val,
                    pageSize=(upper - lower) / 100.0,
                    scale=0.3,
                    pos=(x, 0, y),
                    command=self._on_locked_slider_change,
                )
                name_label = DirectLabel(
                    text=f"{name} (locked)",
                    scale=0.05,
                    pos=(x - 0.45, 0, y + 0.02),
                    frameColor=(0, 0, 0, 0),
                    text_fg=(1, 1, 1, 1),
                    text_align=TextNode.ALeft,
                )
                name_label.reparentTo(self.aspect2d)
                value_label = DirectLabel(
                    text=f"{val:.2f} rad",
                    scale=0.05,
                    pos=(x + 0.36, 0, y + 0.02),
                    frameColor=(0, 0, 0, 0),
                    text_fg=(0.5, 1.0, 0.5, 1.0),
                    text_align=TextNode.ALeft,
                )
                value_label.reparentTo(self.aspect2d)
                self.locked_sliders.append((joint_idx, slider))
                self.locked_labels.append((value_label, joint_idx))
                y -= 0.12

        # Reset objects button (bottom-right).
        try:
            from direct.gui.DirectGui import DirectButton

            btn = DirectButton(
                text="Reset Objects",
                scale=0.06,
                pos=(0.75, 0, -0.9),
                command=self._reset_hoops,
                frameColor=(0.18, 0.18, 0.22, 0.8),
                text_fg=(1, 1, 1, 1),
                text_align=TextNode.ACenter,
                relief=1,
            )
            btn.setTransparency(TransparencyAttrib.MAlpha)
            btn.setBin("fixed", 100)
        except Exception:
            pass

    def _setup_lock_status(self) -> None:
        """Overlay label showing current grasp/lock status."""
        try:
            self.lock_status_label = DirectLabel(
                text="Lock: none",
                scale=0.06,
                pos=(-1.25, 0, 0.92),
                frameColor=(0, 0, 0, 0),
                text_fg=(1, 1, 1, 1),
                text_align=TextNode.ALeft,
            )
        except Exception:
            self.lock_status_label = None

    def _bind_controls(self) -> None:
        self.accept("escape", self._quit)
        self.accept("r", self._reset)
        self.accept("space", self._toggle_pause)
        self.accept("+", self._zoom, [-0.05])
        self.accept("=", self._zoom, [-0.05])
        self.accept("-", self._zoom, [0.05])
        self.accept("arrow_left", self._orbit, [-5, 0])
        self.accept("arrow_right", self._orbit, [5, 0])
        self.accept("arrow_up", self._orbit, [0, 5])
        self.accept("arrow_down", self._orbit, [0, -5])
        # Mouse controls
        self.accept("mouse1", self._start_orbit_drag)
        self.accept("mouse1-up", self._stop_drag)
        self.accept("mouse3", self._start_pan_drag)  # right click
        self.accept("mouse3-up", self._stop_drag)
        self.accept("wheel_up", self._zoom, [-0.05])
        self.accept("wheel_down", self._zoom, [0.05])
        # Grasp helpers
        self.accept("g", self._grasp_contact)
        self.accept("h", self._release_grasp)
        # Keyboard pan
        pan_step = 0.02
        self.accept("w", self._pan_target, [0, pan_step])
        self.accept("w-repeat", self._pan_target, [0, pan_step])
        self.accept("s", self._pan_target, [0, -pan_step])
        self.accept("s-repeat", self._pan_target, [0, -pan_step])
        self.accept("a", self._pan_target, [-pan_step, 0])
        self.accept("a-repeat", self._pan_target, [-pan_step, 0])
        self.accept("d", self._pan_target, [pan_step, 0])
        self.accept("d-repeat", self._pan_target, [pan_step, 0])

    def _update_task(self, task):
        if not self.paused:
            self.physics.step(dt=task.dt)
        self._sync_models()
        self._sync_point_labels()
        self._update_hoop_labels()
        self._update_lock_status()
        if self.show_sliders:
            self._update_joint_labels()
        self._handle_mouse()
        self._update_camera()
        self._update_fps(task.dt)
        return task.cont

    def _sync_models(self) -> None:
        poses = self.physics.get_link_poses()
        for name, node in self.link_nodes.items():
            if name not in poses:
                continue
            pos, orn = poses[name]
            node.setPos(pos[0], pos[1], pos[2])
            node.setQuat(LQuaternionf(orn[3], orn[0], orn[1], orn[2]))
        # Update any spawned kinematic/dynamic meshes.
        for body_id, node in self.kinematic_body_nodes:
            try:
                pos, orn = p.getBasePositionAndOrientation(body_id, physicsClientId=self.physics.client)
            except Exception:
                continue
            node.setPos(pos[0], pos[1], pos[2])
            node.setQuat(LQuaternionf(orn[3], orn[0], orn[1], orn[2]))

    def _sync_point_labels(self) -> None:
        """Create/update/remove point label nodes to mirror the env list."""
        try:
            labels = self.physics.get_point_labels()
        except Exception:
            labels = []
        seen: set[int] = set()
        for label in labels:
            seen.add(label.label_id)
            self._ensure_point_label_node(label)
        # Remove stale labels that no longer exist in the env.
        for label_id in list(self.point_label_nodes.keys()):
            if label_id in seen:
                continue
            try:
                root, _, marker = self.point_label_nodes[label_id]
                marker.removeNode()
                root.removeNode()
            except Exception:
                pass
            self.point_label_nodes.pop(label_id, None)

    def _update_camera(self) -> None:
        cam_pos = self._spherical_to_cartesian(self.cam_distance, math.radians(self.cam_yaw), math.radians(self.cam_pitch))
        self.camera.setPos(self.cam_target + cam_pos)
        self.camera.lookAt(self.cam_target)

    def _update_fps(self, dt: float) -> None:
        if not self.fps_label:
            return
        if dt <= 1e-6:
            return
        fps = 1.0 / dt
        self.fps_label["text"] = f"FPS: {fps:5.1f}"

    def _update_joint_labels(self) -> None:
        """Refresh slider labels with current joint angles."""
        if not (self.joint_labels or self.locked_labels):
            return
        try:
            joint_values = self.physics.get_joint_positions()
        except Exception:
            joint_values = []
        for value_label, idx in self.joint_labels:
            if idx < len(joint_values):
                value_label["text"] = f"{joint_values[idx]:+.2f} rad"
        if self.locked_labels:
            indices = [idx for _, idx in self.locked_labels]
            locked_values: Dict[int, float] = {}
            try:
                vals = self.physics.get_joint_positions(indices=indices)
                for joint_idx, val in zip(indices, vals):
                    locked_values[joint_idx] = val
            except Exception:
                pass
            for value_label, joint_idx in self.locked_labels:
                if joint_idx in locked_values:
                    value_label["text"] = f"{locked_values[joint_idx]:+.2f} rad"

    def _get_grasp_info(self) -> Dict[str, object] | None:
        """Fetch active grasp/lock info from the physics backend (with legacy fallback)."""
        getter = getattr(self.physics, "get_active_grasp_info", None)
        if getter is None:
            getter = getattr(self.physics, "get_active_hoop_info", None)
        if getter is None:
            return None
        try:
            return getter()  # type: ignore[call-arg]
        except Exception:
            return None

    def _current_locked_body_id(self) -> int | None:
        """Return the currently locked body id, if any."""
        info = self._get_grasp_info()
        if not info:
            return None
        for key in ("grasp_body_id", "hoop_body_id", "body_id"):
            val = info.get(key)
            try:
                if val is None:
                    continue
                return int(val)
            except Exception:
                continue
        return None

    def _update_lock_status(self) -> None:
        """Update lock overlay and highlight the currently grasped body (if any)."""
        info = self._get_grasp_info()
        locked_id = self._current_locked_body_id()
        # Restore previous color if lock changed.
        if self._locked_body_id is not None and self._locked_body_id != locked_id:
            node = next((n for bid, n in self.kinematic_body_nodes if bid == self._locked_body_id), None)
            if node and self._locked_body_id in self._locked_original_colors:
                try:
                    node.setColor(self._locked_original_colors[self._locked_body_id])
                except Exception:
                    pass
            self._locked_body_id = None

        if self.lock_status_label is None:
            return
        if locked_id is None:
            self.lock_status_label["text"] = "Lock: none"
            self.lock_status_label["text_fg"] = (1, 1, 1, 1)
            return

        parent_link = info.get("parent_link") if info else None
        link_name = self.idx_to_name.get(int(parent_link), "") if parent_link is not None else ""
        self.lock_status_label["text"] = f"Lock: {locked_id} via {link_name or 'gripper'}"
        self.lock_status_label["text_fg"] = (0.5, 1.0, 0.5, 1.0)
        self._locked_body_id = locked_id
        node = next((n for bid, n in self.kinematic_body_nodes if bid == locked_id), None)
        if node:
            if locked_id not in self._locked_original_colors:
                try:
                    self._locked_original_colors[locked_id] = node.getColor()
                except Exception:
                    self._locked_original_colors[locked_id] = Vec4(1, 1, 1, 1)
            try:
                node.setColor(Vec4(0.4, 1.0, 0.4, 1.0))
            except Exception:
                pass

    def _create_grid(self) -> None:
        """Grid sized by per-axis cell counts and step."""
        step = self.grid_step
        size_x_neg = self.grid_x_neg_cells * step
        size_x_pos = self.grid_x_pos_cells * step
        size_y_neg = self.grid_y_neg_cells * step
        size_y_pos = self.grid_y_pos_cells * step
        ls = LineSegs()
        ls.setColor(0.65, 0.65, 0.7, 0.8)
        for x in frange(-size_x_neg, size_x_pos + 1e-6, step):
            ls.moveTo(x, -size_y_neg, 0)
            ls.drawTo(x, size_y_pos, 0)
        for y in frange(-size_y_neg, size_y_pos + 1e-6, step):
            ls.moveTo(-size_x_neg, y, 0)
            ls.drawTo(size_x_pos, y, 0)
        grid = self.render.attachNewNode(ls.create())
        grid.setTransparency(True)
        grid.setLightOff()
        grid.setBin("background", 5)
        grid.setDepthOffset(1)

    def _setup_static_meshes(self) -> None:
        """Load the pine base and colored accent meshes (visual-only)."""
        models_dir = Path(__file__).resolve().parent / "models"

        if self.show_base:
            base_path = Path(self.base_mesh_path) if self.base_mesh_path else models_dir / "pinebase.stl"
            base_node = self._load_mesh(base_path)
            base_node.reparentTo(self.render)
            base_node.setH(self.base_yaw_deg)  # rotate around Z at the origin
            base_node.setTwoSided(True)
            base_node.setScale(self._as_vec3(self.base_mesh_scale))
            base_node.setShaderAuto(True)
            mat = Material()
            # Soft pine-like tint with subtle sheen.
            diffuse = Vec4(0.82, 0.72, 0.55, 1)
            mat.setDiffuse(diffuse)
            mat.setAmbient(diffuse * 0.85)
            mat.setSpecular(Vec4(0.12, 0.1, 0.08, 1))
            mat.setShininess(8.0)
            base_node.setMaterial(mat, 1)
            base_node.setColor(Vec4(1, 1, 1, 1))

        if self.show_accents:
            accent_defs = [
                ("green", self.green_accent_path, Vec4(0.25, 0.75, 0.35, 1)),
                ("blue", self.blue_accent_path, Vec4(0.2, 0.45, 0.92, 1)),
            ]
            for name, override, color in accent_defs:
                path = Path(override) if override else models_dir / f"{name}accent.stl"
                node = self._load_mesh(path)
                node.reparentTo(self.render)
                node.setH(self.base_yaw_deg)
                node.setTwoSided(True)
                node.setScale(self._as_vec3(self.base_mesh_scale))
                node.setShaderAuto(True)
                mat = Material()
                mat.setDiffuse(color)
                mat.setAmbient(color * 0.8)
                mat.setSpecular(Vec4(0.1, 0.1, 0.1, 1))
                mat.setShininess(6.0)
                node.setMaterial(mat, 1)
                node.setColor(Vec4(1, 1, 1, 1))

    def _setup_kinematic_objects(self) -> None:
        if not self.physics.kinematic_objects:
            return
        for obj in self.physics.kinematic_objects:
            node = self._load_mesh(obj.visual_path)
            node.reparentTo(self.render)
            scale_vec = self._as_vec3(obj.scale)
            # Try to mirror whatever scale Bullet is using, falling back to the stored value.
            try:
                shape_data = p.getVisualShapeData(obj.body_id, -1, physicsClientId=self.physics.client)
                if shape_data:
                    dims = shape_data[0][3]
                    scale_vec = self._as_vec3(dims)
            except Exception:
                pass
            node.setPos(obj.position[0], obj.position[1], obj.position[2])
            node.setQuat(
                LQuaternionf(
                    obj.orientation_xyzw[3],
                    obj.orientation_xyzw[0],
                    obj.orientation_xyzw[1],
                    obj.orientation_xyzw[2],
                )
            )
            node.setScale(scale_vec)
            node.setTwoSided(True)
            node.setShaderAuto(True)
            if obj.rgba:
                color = Vec4(*obj.rgba)
                node.setColor(color)
                mat = Material()
                mat.setDiffuse(color)
                mat.setAmbient(color * 0.8)
                mat.setSpecular(Vec4(0.08, 0.08, 0.08, 1))
                mat.setShininess(6.0)
                node.setMaterial(mat, 1)
            self.kinematic_nodes.append(node)
            self.kinematic_body_nodes.append((obj.body_id, node))
            if self.show_hoop_labels and "hoop" in obj.visual_path.name.lower():
                self._ensure_hoop_label(obj.body_id, suggested_name=obj.visual_path.stem or "Hoop")

    def _setup_point_labels(self) -> None:
        """Create any user-provided point labels from the physics backend."""
        try:
            labels = self.physics.get_point_labels()
        except Exception:
            labels = []
        for label in labels:
            self._ensure_point_label_node(label)

    def _ensure_hoop_label(self, body_id: int, suggested_name: str = "Hoop") -> None:
        """Create a label anchored to a hoop's centroid."""
        if body_id in self.hoop_label_nodes:
            return
        self._hoop_label_counter += 1
        label_name = suggested_name
        if label_name.lower() in (n.lower() for n in self.hoop_names.values()):
            label_name = f"{label_name} {self._hoop_label_counter}"
        self.hoop_names[body_id] = label_name
        root = self.render.attachNewNode(f"hoop-label-{body_id}")
        root.setLightOff()
        root.setTransparency(TransparencyAttrib.MAlpha)
        marker = self._create_label_marker((1.0, 0.3, 0.3, 1.0))
        marker.reparentTo(root)
        txt_node = TextNode(f"hoop-text-{body_id}")
        txt_node.setAlign(TextNode.ALeft)
        txt_node.setTextColor(Vec4(1.0, 0.3, 0.3, 1.0))
        text_np = root.attachNewNode(txt_node)
        text_np.setBillboardPointEye()
        text_np.setScale(0.022)
        text_np.setPos(0.012, 0, 0.028)
        text_np.setColor(Vec4(1.0, 0.3, 0.3, 1.0))
        text_np.setTransparency(TransparencyAttrib.MAlpha)
        self.hoop_label_nodes[body_id] = (root, txt_node, marker)

    def _update_single_hoop_label(self, body_id: int, locked: bool | None = None) -> None:
        if body_id not in self.hoop_label_nodes:
            return
        root, txt_node, marker = self.hoop_label_nodes[body_id]
        try:
            pos, _ = p.getBasePositionAndOrientation(body_id, physicsClientId=self.physics.client)
        except Exception:
            pos = (0.0, 0.0, 0.0)
        root.setPos(pos[0], pos[1], pos[2])
        name = self.hoop_names.get(body_id, f"Hoop {body_id}")
        txt_node.setText(name)
        if locked is None:
            locked = body_id == self._current_locked_body_id()
        color = Vec4(0.35, 1.0, 0.4, 1.0) if locked else Vec4(1.0, 0.35, 0.35, 1.0)
        txt_node.setTextColor(color)
        marker.setColor(color)
        marker.setColorScale(color)
        marker.setScale(0.08)

    def _update_hoop_labels(self) -> None:
        if not self.show_hoop_labels or not self.hoop_label_nodes:
            return
        locked_id = self._current_locked_body_id()
        for hoop_id in list(self.hoop_label_nodes.keys()):
            self._update_single_hoop_label(hoop_id, locked=hoop_id == locked_id)

    def _ensure_point_label_node(self, label: PointLabel) -> None:
        entry = self.point_label_nodes.get(label.label_id)
        if entry is None:
            root = self.render.attachNewNode(f"label-{label.label_id}")
            root.setLightOff()
            root.setTransparency(TransparencyAttrib.MAlpha)
            marker = self._create_label_marker(label.color_rgba)
            marker.reparentTo(root)
            txt_node = TextNode(f"label-text-{label.label_id}")
            txt_node.setAlign(TextNode.ALeft)
            txt_node.setTextColor(Vec4(*label.color_rgba))
            text_np = root.attachNewNode(txt_node)
            text_np.setBillboardPointEye()
            text_np.setScale(label.text_scale)
            # Keep the label tight to the crosshair: small horizontal/vertical offset.
            text_np.setPos(label.text_scale * 0.35, 0, label.text_scale * 0.65 + 0.005)
            text_np.setColor(Vec4(*label.color_rgba))
            text_np.setTransparency(TransparencyAttrib.MAlpha)
            self.point_label_nodes[label.label_id] = (root, txt_node, marker)
        root, txt_node, marker = self.point_label_nodes[label.label_id]
        color = Vec4(*label.color_rgba)
        txt_node.setText(self._format_label_text(label))
        txt_node.setTextColor(color)
        marker.setColor(color)
        marker.setColorScale(color)  # ensure crosshair tint updates even with vertex colors
        marker.setScale(max(0.005, label.marker_scale))
        root.setPos(label.position[0], label.position[1], label.position[2])

    def _create_label_marker(self, color_rgba: tuple[float, float, float, float]) -> NodePath:
        """Crosshair marker; scale is applied per-label in _ensure_point_label_node."""
        half = 1.0
        ls = LineSegs()
        ls.setThickness(4.5)
        ls.setColor(*color_rgba)
        axes = [
            (Vec3(-half, 0, 0), Vec3(half, 0, 0)),
            (Vec3(0, -half, 0), Vec3(0, half, 0)),
            (Vec3(0, 0, -half * 0.35), Vec3(0, 0, half * 1.4)),
        ]
        for start, end in axes:
            ls.moveTo(start)
            ls.drawTo(end)
        node = ls.create()
        marker = NodePath(node)
        marker.setTransparency(TransparencyAttrib.MAlpha)
        marker.setDepthOffset(4)
        marker.setLightOff()
        return marker

    def _format_label_text(self, label: PointLabel) -> str:
        if label.show_coords:
            x, y, z = label.position
            return f"{label.name} ({x:+.3f}, {y:+.3f}, {z:+.3f})"
        return label.name

    def _load_mesh(self, path: Path) -> NodePath:
        try:
            if self.reload_meshes:
                opts = LoaderOptions(LoaderOptions.LFNoCache)
                return self.loader.loadModel(Filename.fromOsSpecific(str(path)), loaderOptions=opts)
            return self.loader.loadModel(Filename.fromOsSpecific(str(path)))
        except Exception:
            # Fallback to a simple box if the mesh cannot be loaded.
            try:
                return self.loader.loadModel("models/box")
            except Exception:
                cm_node = self.render.attachNewNode("placeholder")
                cm_node.setScale(0.02)
                return cm_node

    @staticmethod
    def _as_vec3(scale) -> Vec3:
        """Coerce a scale value (scalar/iterable/string) to a Vec3."""
        if scale is None:
            return Vec3(1.0, 1.0, 1.0)
        if isinstance(scale, (str, bytes)):
            try:
                val = float(scale)
            except Exception:
                val = 1.0
            return Vec3(val, val, val)
        if isinstance(scale, (int, float)):
            val = float(scale)
            return Vec3(val, val, val)
        try:
            vals = list(scale)
        except Exception:
            return Vec3(1.0, 1.0, 1.0)
        if len(vals) == 1:
            v = float(vals[0])
            return Vec3(v, v, v)
        if len(vals) >= 3:
            return Vec3(float(vals[0]), float(vals[1]), float(vals[2]))
            return Vec3(1.0, 1.0, 1.0)

    def _on_joint_slider_change(self) -> None:
        self._apply_slider_targets()

    def _on_gripper_slider_change(self) -> None:
        if self._gripper_pair_slider is None or self._gripper_slider_target_indices is None:
            return
        grip = self._gripper_pair_slider["value"]
        idx1a, idx2a = self._gripper_slider_target_indices
        try:
            # Positive slider closes: 1A goes negative, 2A goes positive (mirrored finger).
            self.joint_sliders[idx1a]["value"] = -grip
            self.joint_sliders[idx2a]["value"] = grip
        except Exception:
            pass
        self._apply_slider_targets()

    def _on_locked_slider_change(self) -> None:
        # Push locked joint slider values into the physics backend.
        for joint_idx, slider in self.locked_sliders:
            try:
                self.physics.set_locked_joint(joint_idx, slider["value"])
            except Exception:
                continue

    def _apply_slider_targets(self) -> None:
        values = [slider["value"] for slider in self.joint_sliders]
        self.physics.set_joints(values)
        for joint_idx, slider in self.locked_sliders:
            try:
                self.physics.set_locked_joint(joint_idx, slider["value"])
            except Exception:
                continue

    def _reset_hoops(self) -> None:
        """Reset spawned objects to their original poses if available."""
        try:
            if hasattr(self.physics, "env") and hasattr(self.physics.env, "reset"):
                if hasattr(self.physics.env, "reset_objects"):
                    self.physics.env.reset_objects()  # type: ignore[attr-defined]
                else:
                    self.physics.env.reset_hoops()  # type: ignore[attr-defined]
        except Exception as exc:
            print("[PandaViewer] Failed to reset hoops:", exc)

    def _zoom(self, delta: float) -> None:
        self.cam_distance = max(0.1, self.cam_distance + delta)

    def _orbit(self, dyaw: float, dpitch: float) -> None:
        self.cam_yaw = (self.cam_yaw + dyaw) % 360
        self.cam_pitch = max(-89.0, min(89.0, self.cam_pitch + dpitch))

    def _pan_target(self, dx: float, dy: float) -> None:
        self.cam_target += Vec3(dx, dy, 0)

    def _reset(self) -> None:
        self.physics.home()
        for slider in self.joint_sliders:
            slider["value"] = 0.0
        if self._gripper_pair_slider is not None:
            self._gripper_pair_slider["value"] = 0.0
        self._apply_slider_targets()

    def _grasp_contact(self) -> None:
        cid = self.physics.grasp_from_contacts()
        if cid is not None:
            print(f"[PandaViewer] Grasp constraint created (id={cid}).")

    def _release_grasp(self) -> None:
        if self.physics.active_grasp_cid is not None:
            print(f"[PandaViewer] Releasing grasp constraint (id={self.physics.active_grasp_cid}).")
        self.physics.release_grasp()

    def _toggle_pause(self) -> None:
        self.paused = not self.paused

    def _quit(self) -> None:
        self.userExit()

    def _start_orbit_drag(self) -> None:
        self._orbit_drag = True
        if self.mouseWatcherNode.hasMouse():
            m = self.mouseWatcherNode.getMouse()
            self._last_mouse = (m.getX(), m.getY())

    def _start_pan_drag(self) -> None:
        self._pan_drag = True
        if self.mouseWatcherNode.hasMouse():
            m = self.mouseWatcherNode.getMouse()
            self._last_mouse = (m.getX(), m.getY())

    def _stop_drag(self) -> None:
        self._orbit_drag = False
        self._pan_drag = False
        self._last_mouse = None

    def _handle_mouse(self) -> None:
        if not self.mouseWatcherNode.hasMouse():
            return
        current = self.mouseWatcherNode.getMouse()
        x, y = current.getX(), current.getY()
        if self._last_mouse is None:
            self._last_mouse = (x, y)
            return
        dx = x - self._last_mouse[0]
        dy = y - self._last_mouse[1]
        self._last_mouse = (x, y)
        if self._orbit_drag:
            self._orbit(dx * -200, dy * -200)  # invert horizontal for orbit
        elif self._pan_drag:
            # Pan in the view plane (camera right/up).
            cam_quat = self.camera.getQuat(self.render)
            right = cam_quat.getRight()
            up = cam_quat.getUp()
            pan_scale = self.cam_distance * 0.5
            move = (right * dx * -pan_scale) + (up * dy * -pan_scale)  # invert horizontal and vertical for pan
            self.cam_target += move

    @staticmethod
    def _spherical_to_cartesian(radius: float, yaw: float, pitch: float) -> Vec3:
        x = radius * math.cos(pitch) * math.cos(yaw)
        y = radius * math.cos(pitch) * math.sin(yaw)
        z = radius * math.sin(pitch)
        return Vec3(x, y, z)


def frange(start: float, stop: float, step: float):
    val = start
    while val <= stop + 1e-9:
        yield round(val, 6)
        val += step


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Panda3D viewer for the QArm with PyBullet physics.")
    parser.add_argument("--time-step", type=float, default=1.0 / 120.0, help="Physics timestep (seconds).")
    parser.add_argument("--hide-base", action="store_true", help="Do not load the pine base mesh.")
    parser.add_argument("--hide-accents", action="store_true", help="Do not load the accent meshes.")
    parser.add_argument(
        "--probe-base-collision",
        action="store_true",
        help="Drop a small probe to verify the base collision mesh is active (prints contact info).",
    )
    parser.add_argument(
        "--reload-meshes",
        action="store_true",
        help="Force Panda3D to reload STL meshes (bypass cache) for live mesh edits.",
    )
    parser.add_argument(
        "--show-hoop-labels",
        action="store_true",
        help="Show centroid labels on hoops (tint green when locked).",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    base_assets = DEFAULT_BASE_ASSETS
    # Log the chosen assets so it's obvious which collision is active.
    print("[PandaViewer] base visual mesh:", base_assets.visual_mesh)
    print("[PandaViewer] base collision mesh:", base_assets.collision_mesh)
    print("[PandaViewer] base visual scale:", base_assets.visual_scale)
    print("[PandaViewer] base collision scale:", base_assets.collision_scale)
    print("[PandaViewer] base yaw:", base_assets.yaw_deg)
    print("[PandaViewer] base friction/restitution:", base_assets.friction, base_assets.restitution)
    physics = PhysicsBridge(
        time_step=args.time_step,
        base_assets=base_assets,
    )
    if args.probe_base_collision:
        physics.probe_base_collision()
    app = PandaArmViewer(physics, args)
    app.run()


if __name__ == "__main__":
    main()
